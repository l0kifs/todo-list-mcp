# Документ требований
**Проект:** MCP сервер для Cursor IDE (менеджмент задач и напоминаний)  
**Дата:** 2024-06-13  
**Версия:** 1.2 (финальный)

---

## 1. Цель проекта

Создать локальный MCP сервер для Cursor IDE, который:
- Запускается через uv (Python, pyproject.toml).
- Работает локально на macOS и Linux (разработка и тестирование — на Linux).
- Управляет задачами и напоминаниями.
- Позволяет AI-агенту создавать задачи и напоминания через MCP-интерфейс.
- Сохраняет задачи и напоминания в локальную БД.
- Имеет постоянный singleton-воркер, который отслеживает напоминания и показывает их на экране в назначенное время.

---

## 2. Основные функции

### 2.1. Управление задачами
- Создание, обновление, удаление задач.
- Хранение задач в локальной БД (SQLite через SQLAlchemy).
- Возможность добавлять описание, приоритет, статус, дедлайны, зависимости.

### 2.2. Управление напоминаниями
- Создание напоминания с указанием времени (например, "через час").
- **Привязка напоминания к задаче обязательна** (напоминание не может существовать без задачи).
- Хранение напоминаний в БД.
- Возможность просматривать, редактировать, удалять напоминания.

### 2.3. MCP и CLI интерфейс
- Сервер реализует Model Context Protocol (через fastmcp).
- Экспортирует MCP-инструменты для управления задачами и напоминаниями.
- CLI-интерфейс для локального управления задачами и напоминаниями (через typer).
- **Обязательные команды CLI:** включить и выключить воркер.
- Сервер запускается через uv (pyproject.toml, uv lock).

### 2.4. Воркер напоминаний (singleton)
- Фоновый процесс, запускаемый вместе с сервером.
- Singleton: только один активный воркер на систему, независимо от числа запусков/перезапусков сервера.
- **Механизм singleton — блокировка в БД** (например, через специальную таблицу/флаг).
- Воркер продолжает работать при выключении MCP, его перезапуске, или запуске нескольких копий.
- Воркер использует таблицу состояний в БД для синхронизации и управления (сервер может выключить воркер через эту таблицу).
- Проверяет БД раз в 10 секунд.
- Если есть напоминания с наступившим временем — показывает уведомление.
- Формат уведомлений — **кастомное окно на PyQt6** (расширенная настройка пока не требуется, PyQt6 обязателен для GUI-уведомлений, tkinter/plyer не использовать).
- После показа уведомления помечает напоминание как "уведомленное".
- **Логирование уведомлений — только в логах приложения, отдельного хранения не требуется.**
- **[НОВОЕ]** При наступлении времени напоминания:
    - Открывается отдельное кастомное окно уведомления (GUI) для каждого напоминания **только через PyQt6**.
    - Окно не исчезает автоматически, только по явному действию пользователя (кнопка "Закрыть" или аналогичная).
    - Одновременно с появлением окна:
        - Воспроизводится стандартный beep (через PyQt6: `QApplication.beep()` или аналог).
        - Если окно не закрыто, beep повторяется каждые 5 минут (300 секунд) до закрытия окна (использовать QTimer).
    - После закрытия окна:
        - Звуковое оповещение прекращается.
        - Напоминание помечается как "уведомленное" в БД.
    - При ошибке beep — ошибка логируется, окно всё равно показывается.
    - Для каждого одновременного напоминания — отдельное окно и отдельный beep/таймер.
    - Fallback на другие GUI-библиотеки не требуется, PyQt6 обязателен.

---

## 3. Технические требования

- **Язык:** Python 3.11+
- **Стек:**  
  - uv (управление зависимостями)
  - fastapi (API, если потребуется)
  - fastmcp (MCP-интеграция)
  - typer (CLI)
  - sqlalchemy (ORM, SQLite)
  - pydantic (валидация данных)
  - pydantic-settings (конфиг)
  - loguru (логирование)
  - httpx (если потребуется внешнее взаимодействие)
  - rich (терминальные уведомления, если потребуется)
  - PyQt6 (для кастомных окон уведомлений, tkinter/plyer не использовать)
- **ОС:** macOS и Linux (разработка и тестирование — на Linux)
- **Безопасность:** ограничений не требуется
- **Миграции БД:** не требуются

---

## 4. MCP-инструменты (методы)

- create_task (описание, дедлайн, приоритет, ...)
- update_task
- delete_task
- list_tasks
- create_reminder (описание, время, **обязательная привязка к задаче**)
- update_reminder
- delete_reminder
- list_reminders

---

## 5. Воркер

- Singleton-воркер, запускается как отдельный процесс при старте сервера.
- **В любой момент времени в базе может быть только один PID воркера (отдельное поле).**
- MCP-сервер при запуске:
    - Читает PID воркера из базы.
    - Проверяет, существует ли процесс с этим PID.
    - Если процесс не найден — запускает новый воркер-процесс, сохраняет его PID в базе.
    - Если процесс найден — новый воркер не запускается.
- MCP-сервер может завершить воркер по PID (например, по команде из CLI), после чего PID очищается или обновляется при запуске нового воркера.
- Все действия по запуску, завершению, перезапуску воркера и изменению PID логируются.
- Воркер использует блокировку в БД для синхронизации и управления.
- Проверяет БД раз в 10 секунд.
- Если есть напоминания с наступившим временем — показывает **кастомное окно**.
- После показа уведомления помечает напоминание как "уведомленное".
- Сервер может выключить воркер через изменение состояния в БД.
- Логирование уведомлений — только в логах приложения.
- **[НОВОЕ]** Поведение при уведомлениях:
    - Для каждого напоминания открывается отдельное окно уведомления.
    - Окно не исчезает до ручного закрытия.
    - При появлении окна beep проигрывается 3 секунды, затем повторяется каждые 5 минут, пока окно не закрыто.
    - При ошибке beep — ошибка логируется, окно всё равно показывается.

---

## 6. Неоднозначности и вопросы

- **Формат кастомного окна:** расширенная настройка пока не требуется.
- **CLI:** обязательные команды — включить и выключить воркер.
- **Механизм singleton:** блокировка в БД.
- **Логирование уведомлений:** только в логах приложения.
- **Миграции БД:** не требуются.
- **[НОВОЕ]** При множественных одновременных напоминаниях — каждое вызывает отдельное окно и beep.

---

## 7. Пример сценария

1. Пользователь через Cursor IDE пишет: "Напомни через час о задаче X".
2. Агент вызывает MCP-инструмент create_task + create_reminder (через час, обязательно с привязкой к задаче).
3. Сервер сохраняет задачу и напоминание в БД.
4. Singleton-воркер отслеживает время, через час показывает **кастомное окно** на экране.
5. После показа уведомления воркер помечает напоминание как "уведомленное".

---

## 8. Соответствие внутренним правилам

- Используются только проверенные компоненты из docs/python-tech-stack.md.
- Все требования формализованы и подлежат ревью.
- После одобрения документа будет вестись разработка строго по согласованным требованиям.
- **Финальные правила singleton-воркера: запуск как отдельного процесса, хранение PID в базе в одном поле, автоматический контроль и перезапуск, логирование.** 